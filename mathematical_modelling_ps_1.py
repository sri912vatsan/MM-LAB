# -*- coding: utf-8 -*-
"""Mathematical Modelling PS 1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XywWiHROaJYb_7LabW7C7BZ7IfRHuGFf
"""

import numpy as np
import matplotlib.pyplot as plt

# Number of samples
sample_sizes = [500, 1000, 10000, 100000]

# Function to plot histogram and frequency polygon
def plot_histogram_and_polygon(data, title):
    plt.figure(figsize=(6, 4))

    count, bins,_ = plt.hist(data, bins=50, density=True, alpha=0.6, color='g', edgecolor='black')

    bin_centers = 0.5 * (bins[1:] + bins[:-1])
    plt.plot(bin_centers, count, '-o', color='b')

    plt.title(title)
    plt.xlabel('Value')
    plt.ylabel('Frequency')
    plt.show()

for size in sample_sizes:
    uniform_data = np.random.uniform(low=0.0, high=1.0, size=size)
    plot_histogram_and_polygon(uniform_data, f'Uniform Distribution with {size} samples')

for size in sample_sizes:
    exponential_data = np.random.exponential(scale=1.0, size=size)
    plot_histogram_and_polygon(exponential_data, f'Exponential Distribution with {size} samples')

def generate_weibull_data(shape, size):
    return np.random.weibull(shape, size)

for size in sample_sizes:
    weibull_data = generate_weibull_data(1.5, size)
    plot_histogram_and_polygon(weibull_data, f'Weibull Distribution with {size} samples')

# Triangular distribution (using numpy)
def generate_triangular_data(left, mode, right, size):
    return np.random.triangular(left, mode, right, size)

for size in sample_sizes:
    triangular_data = generate_triangular_data(0, 0.5, 1, size)  # mode at c=0.5
    plot_histogram_and_polygon(triangular_data, f'Triangular Distribution with {size} samples')

import random

INTERVAL = 1000

circle_points = 0
square_points = 0

for i in range(INTERVAL**2):

	x = random.uniform(-1, 1)
	y = random.uniform(-1, 1)

	origin_dist = x**2 + y**2

	if origin_dist <= 1:
		circle_points += 1

	square_points += 1

	pi = 4 * circle_points / square_points


print("Final Estimation of Pi=", pi)

"""Q3 - Integration"""

import numpy as np
import matplotlib.pyplot as plt

def integrand(theta):
    return np.sin(np.pi * np.cos(np.cos(3 * theta)))**2 * np.cos(theta)**2

def monte_carlo_integration(integrand_func, num_samples):

    theta_samples = np.random.uniform(low=0, high=np.pi, size=num_samples)
    integrand_values = integrand_func(theta_samples)
    integral_estimate = np.pi * np.mean(integrand_values)

    return integral_estimate

integral_estimate = monte_carlo_integration(integrand, 1000)

print("Monte Carlo estimated integral with N=1000",integral_estimate)

theta_values = np.linspace(0, np.pi)
integrand_values = integrand(theta_values)

plt.figure(figsize=(10, 6))
plt.plot(theta_values, integrand_values)
plt.title('Graph of the Integrand')
plt.xlabel(r'$\theta$')
plt.ylabel('Function Value')
plt.legend()
plt.grid(True)
plt.show()

"""Q4"""

import numpy as np

class QueueSystem:
    def __init__(self, arrival_dist, service_dist, n_samples):
        self.arrival_dist = arrival_dist
        self.service_dist = service_dist
        self.n_samples = n_samples

        self.arrival_times = []
        self.service_times = []
        self.start_service_times = []
        self.finish_service_times = []
        self.queue_lengths = []

    def simulate(self):
        current_time = 0
        for _ in range(self.n_samples):
            inter_arrival_time = self.arrival_dist()
            service_time = self.service_dist()

            arrival_time = current_time + inter_arrival_time
            start_service_time = max(arrival_time, self.finish_service_times[-1] if self.finish_service_times else 0)
            finish_service_time = start_service_time + service_time

            self.arrival_times.append(arrival_time)
            self.service_times.append(service_time)
            self.start_service_times.append(start_service_time)
            self.finish_service_times.append(finish_service_time)

            current_time = arrival_time

            self.queue_lengths.append(sum(1 for finish_time in self.finish_service_times if finish_time > arrival_time))

    def calculate_parameters(self):
        waiting_times_in_queue = [start - arrival for start, arrival in zip(self.start_service_times, self.arrival_times)]
        waiting_times_in_system = [finish - arrival for finish, arrival in zip(self.finish_service_times, self.arrival_times)]

        average_waiting_time_in_queue = np.mean(waiting_times_in_queue)
        average_length_of_queue = np.mean(self.queue_lengths)
        average_waiting_time_in_system = np.mean(waiting_times_in_system)

        return average_waiting_time_in_queue, average_length_of_queue, average_waiting_time_in_system


np.random.seed(0)  # For reproducibility
arrival_dist_poisson = lambda: np.random.exponential(3)
service_dist_exponential = lambda: np.random.exponential(4)

queue_system_poisson = QueueSystem(arrival_dist_poisson, service_dist_exponential, 1000)
queue_system_poisson.simulate()
results_poisson = queue_system_poisson.calculate_parameters()

arrival_dist_uniform = lambda: np.random.uniform(0, 6)

queue_system_uniform = QueueSystem(arrival_dist_uniform, service_dist_exponential, 1000)
queue_system_uniform.simulate()
results_uniform = queue_system_uniform.calculate_parameters()

print("Results for Poisson arrival with exponential service time:")
print(f"Average waiting time in queue: {results_poisson[0]:.2f} seconds")
print(f"Average length of the queue: {results_poisson[1]:.2f}")
print(f"Average waiting time in system: {results_poisson[2]:.2f} seconds")

print("\nResults for Uniform arrival with exponential service time:")
print(f"Average waiting time in queue: {results_uniform[0]:.2f} seconds")
print(f"Average length of the queue: {results_uniform[1]:.2f}")
print(f"Average waiting time in system: {results_uniform[2]:.2f} seconds")

"""Q5 - Optimal assignment"""

import numpy as np

# Demand ranges given in the problem
demand_ranges = [(140, 200), (190, 210), (140, 160), (195, 215), (200, 220),
                 (155, 175), (125, 135), (120, 140), (110, 130), (90, 105)]

np.random.seed(0)  # For reproducibility
demands = [np.random.randint(low, high + 1, 100) for low, high in demand_ranges]

average_demands = [int(np.mean(demand)) for demand in demands]

print("Generated demands for each period (100 samples):")
for i, demand in enumerate(demands, 1):
    print(f"Period {i}: {demand}")

print("\nAverage demand for each period:")
for i, avg_demand in enumerate(average_demands, 1):
    print(f"Period {i}: {avg_demand}")


production_capacities = [(100, 50, 30), (40, 60, 80), (90, 80, 70),
                         (60, 50, 20), (70, 50, 100), (60, 70, 80),
                         (50, 80, 40), (40, 50, 40), (50, 50, 50), (40, 50, 30)]
production_costs = (4, 6, 7)
holding_cost = 0.5


inventory = 0
total_cost = 0

for i, avg_demand in enumerate(average_demands):
    reg_capacity, ot_capacity, sc_capacity = production_capacities[i]
    demand = avg_demand

    if demand <= reg_capacity:
        production = demand
        total_cost += production * production_costs[0]
    elif demand <= reg_capacity + ot_capacity:
        production = reg_capacity + (demand - reg_capacity)
        total_cost += reg_capacity * production_costs[0] + (demand - reg_capacity) * production_costs[1]
    else:
        production = reg_capacity + ot_capacity + (demand - reg_capacity - ot_capacity)
        total_cost += (reg_capacity * production_costs[0] +
                       ot_capacity * production_costs[1] +
                       (demand - reg_capacity - ot_capacity) * production_costs[2])

    inventory += production - demand
    if inventory < 0:
        total_cost += abs(inventory) * production_costs[2]
        inventory = 0
    total_cost += inventory * holding_cost

print(f"\nOptimal total cost: {total_cost:.2f}")

import numpy as np

def simulate_newsstand(n_days, cost_price, selling_price, scrap_price, probs):
    total_revenue = 0
    total_loss = 0
    total_scrap = 0
    total_profit = 0

    news_types = np.random.choice(['good', 'normal', 'poor'], n_days, p=probs)

    demands = {
        'good': np.random.exponential(50, n_days),
        'normal': np.random.normal(50, 10, n_days),
        'poor': np.random.poisson(50, n_days)
    }

    for day in range(n_days):
        news_type = news_types[day]
        demand = demands[news_type][day]

        if news_type == 'good':
            max_demand = 100
        elif news_type == 'normal':
            max_demand = 80
        elif news_type == 'poor':
            max_demand = 60

        sold = min(demand, max_demand)
        scrap = max(0, max_demand - sold)

        revenue = sold * selling_price
        loss = max(0, demand - sold) * (selling_price - cost_price)
        salvage = scrap * scrap_price
        profit = revenue - (sold * cost_price) + salvage

        total_revenue += revenue
        total_loss += loss
        total_scrap += salvage
        total_profit += profit

    avg_profit = total_profit / n_days

    return total_revenue, total_loss, total_scrap, total_profit, avg_profit

n_days = 1000
cost_price = 0.30
selling_price = 0.45
scrap_price = 0.05
probs = [0.35, 0.45, 0.20]

results = simulate_newsstand(n_days, cost_price, selling_price, scrap_price, probs)
print(f'Total Revenue: {results[0]}')
print(f'Total Loss: {results[1]}')
print(f'Total Scrap: {results[2]}')
print(f'Total Profit: {results[3]}')
print(f'Average Profit: {results[4]}')